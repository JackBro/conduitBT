/*++

Module Name:
    Driver.c

Abstract:
    Driver object related functionality for bth HFP device

Environment:
    Kernel mode only
--*/

#include "driver.h"
#include "device.h"

#if defined(EVENT_TRACING)
// The trace message header (.tmh) file must be included in a source file before any WPP macro calls and after defining a WPP_CONTROL_GUIDS
// macro (defined in toaster.h). During the compilation, WPP scans the source files for DoTraceMessage() calls and builds a .tmh file which stores a unique
// data GUID for each message, the text resource string for each message, and the data types of the variables passed in for each message.
// This file is automatically generated and used during post-processing.
#include "driver.tmh"
#else
#define _DRIVER_NAME_ "HfpDriver"
ULONG DebugLevel = TRACE_LEVEL_INFORMATION;
ULONG DebugFlag = 0xffff;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, HfpEvtDriverCleanup)
#endif



NTSTATUS DriverEntry (_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    NTSTATUS				status;
    WDFDRIVER				driver;
    WDF_OBJECT_ATTRIBUTES	attributes;
    WDF_DRIVER_CONFIG		DriverConfig;

    WDF_DRIVER_CONFIG_INIT(&DriverConfig, HfpEvtDriverDeviceAdd);

    WPP_INIT_TRACING (DriverObject, RegistryPath);

    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    attributes.EvtCleanupCallback = HfpEvtDriverCleanup;

    status = WdfDriverCreate(
        DriverObject,
        RegistryPath,
        NULL,
        &DriverConfig,
        &driver
        );

    if(!NT_SUCCESS(status)) {
        WPP_CLEANUP(DriverObject);
    }

    return status;                            
}


void HfpEvtDriverCleanup (_In_ WDFOBJECT DriverObject)
{
    PAGED_CODE ();
    // Driver remains unreferenced if EVENT_TRACING is not defined in which case traces are sent to debugger instead of ETW
    UNREFERENCED_PARAMETER(DriverObject);
    WPP_CLEANUP (WdfDriverWdmGetDriverObject(DriverObject));
}




#if !defined(EVENT_TRACING)

void TraceEvents (_In_ ULONG DebugPrintLevel, _In_ ULONG DebugPrintFlag, _Printf_format_string_ _In_ PCSTR DebugMessage, ...)
{
#if DBG
	#define  TEMP_BUFFER_SIZE  1024
    va_list    list;
    CHAR       debugMessageBuffer[TEMP_BUFFER_SIZE];
    NTSTATUS   status;

    UNREFERENCED_PARAMETER(DebugPrintLevel);
    UNREFERENCED_PARAMETER(DebugPrintFlag);

    va_start(list, DebugMessage);

    if (DebugMessage) {
        // Using new safe string functions instead of _vsnprintf.
        // This function takes care of NULL terminating if the message
        // is longer than the buffer.
        status = RtlStringCbVPrintfA (debugMessageBuffer, sizeof(debugMessageBuffer), DebugMessage, list);
        if(!NT_SUCCESS(status)) {
            DbgPrint (_DRIVER_NAME_": RtlStringCbVPrintfA failed 0x%x\n", status);
            return;
        }

        DbgPrint("%s %s", _DRIVER_NAME_, debugMessageBuffer);

        /*if (DebugPrintLevel <= TRACE_LEVEL_ERROR ||
            (DebugPrintLevel <= DebugLevel && ((DebugPrintFlag & DebugFlag) == DebugPrintFlag))) {
            DbgPrint("%s %s", _DRIVER_NAME_, debugMessageBuffer);
        }*/
    }
    va_end(list);
    return;
#else
    UNREFERENCED_PARAMETER(DebugPrintLevel);
    UNREFERENCED_PARAMETER(DebugPrintFlag);
    UNREFERENCED_PARAMETER(DebugMessage);
#endif
}

#endif

